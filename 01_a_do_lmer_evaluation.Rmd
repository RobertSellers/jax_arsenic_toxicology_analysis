---
title: "DO #1a LMER custom test"
author:
- name: Robert Sellers
  affiliation: The Jackson Laboratory
date: "`r paste('Last knit on:',format(Sys.time(), '%d %B %Y'))`"
abstract: |
latex_engine: pdflatex
output:
  html_document:
    fig_caption: yes
    force_captions: yes
    number_sections: true
    theme: lumen
    toc: yes
    toc_float: yes
    df_print: paged
    # code_folding: "hide"
  pdf_document:
    fig_caption: yes
    force_captions: yes
    highlight: pyments
    keep_tex: yes
    latex_engine: xelatex
    number_sections: no
    toc: no
    
---

# Programming environment

```{r message=FALSE}
# env
setwd('/Users/seller/Desktop/projects/jax_arsenic_toxicology_analysis/')
options(scipen = 999) # suppress sci notation
# contains harmony plate collection class builder
source("scripts/harmony_utils.R")
# various add-on scripts and stats tools
source("scripts/custom_tools.R")
# custom feature selection scripts 
source("scripts/feature_selection.R")

library(tidyverse)
library(janitor)
library(ggplot2) 
library(ggfortify)
library(ggpubr) # ggplot extension
library(ggrepel)
library(lme4)
library(lmerTest)
library(sjPlot)
library(ggthemes)
library(scales)
library(drc)
library(magic)
# library(medrc)
# library(nlme)
```

## Visualization themes

```{r}
# ggplot themes 
source("scripts/ggplot_themes.R")

small_font_theme <- ggplot2::theme(
  axis.text.x = element_text(colour="grey20", size=6, angle=90, hjust=.5, vjust=.5),
  axis.text.y = element_text(colour="grey20", size=6),
  legend.title = element_text(size = 8),
  legend.text = element_text(size = 5)
  )
```

# Load data

## Build plate collection from directory

```{r warning=FALSE, echo = FALSE}
# point to parent data directory
setwd("data/invitro/")
selected_dir <- "./do_focus_merge_2"
# Warning - this currently expects a temp_files data dir 
# Set overwrite to TRUE when underlying data dir has been changed
harmony_collection <- harmony_create_collection(dir = selected_dir, overwrite = FALSE)
```

## Data treatments

```{r warning = FALSE}
# consult https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html

# potentially universal updates
harmony_collection$all_plates <- harmony_collection$all_plates %>% 
  dplyr::rename(dose = concentration) %>%
  add_column(sex = NA, .after="individual") %>%
  mutate(mouse = paste0(gsub('_','.',individual),"_", plate)) %>%
  dplyr::select(plate,row,column,dose,sex,individual, mouse, everything())

# delete from dC20264_B1__20200928T12_28_55Measurement_1_e5 (Z)
# where rows are 6:8 and column is 9
# delete from dC20255_B2__20200926T13_00_37Measurement_2_e6 (Y)
# where rows are 1:6 and column is 10

excludes <- read.csv(text = "
dir,row,column
dC20264_B1__20200928T12_28_55Measurement_1_e5,6,9
dC20264_B1__20200928T12_28_55Measurement_1_e5,7,9
dC20264_B1__20200928T12_28_55Measurement_1_e5,8,9
dC20255_B2__20200926T13_00_37Measurement_2_e6,1,10
dC20255_B2__20200926T13_00_37Measurement_2_e6,2,10
dC20255_B2__20200926T13_00_37Measurement_2_e6,3,10
dC20255_B2__20200926T13_00_37Measurement_2_e6,4,10
dC20255_B2__20200926T13_00_37Measurement_2_e6,5,10
dC20255_B2__20200926T13_00_37Measurement_2_e6,6,10
")

harmony_collection$all_plates <- dplyr::anti_join(harmony_collection$all_plates, excludes)

# unique data cleaning
harmony_collection$all_plates <- harmony_collection$all_plates %>% 
  filter(
  dose != 0.5, 
  individual != '11_20',
  individual != '5346') %>%
  # incorrect pairs
  mutate(plate=ifelse((dir=='dC20222_B2_rerun__20200829T11_01_59Measurement_4_e9'), 'B2', plate)) %>%
  mutate(plate=ifelse((dir=='d20222_B1_Cal__20200825T12_23_59Measurement_3_e6'), 'B1', plate)) %>%
  mutate(plate=ifelse((dir=='d20223_B2_Cal__20200817T11_02_00Measurement_1_e9'), 'A2', plate)) %>%
  mutate(plate=ifelse((dir=='d20223_A1_Cal__20200817T17_03_14Measurement_2_e7'), 'A1', plate)) %>%
  mutate(plate=ifelse((dir=='d20223_A2_Cal__20200818T14_54_58Measurement_1_e6'), 'B2', plate)) %>%
  mutate(plate=ifelse((dir=='d20223_B1_Cal__20200827T10_48_20Measurement_1_e7'), 'B1', plate)) %>%
  # incomplete pairs / ensuring completion of plate column
  mutate(plate=ifelse((dir=='dC20236_B2__20200828T14_45_19Measurement_1_e8'), 'B2', plate)) %>%
  mutate(plate=ifelse((dir=='dC20255_B1__20200925T14_41_51Measurement_5_e6'), 'B1', plate)) %>%
  mutate(plate=ifelse((dir=='dC20255_B2__20200926T13_00_37Measurement_2_e6'), 'B2', plate)) %>%
  mutate(plate=ifelse((dir=='dC20236_B1__20200828T13_12_27Measurement_1_e7'), 'B1', plate)) %>%
  mutate(plate=ifelse((dir=='dC20255_B2_last3columns__20200928T09_33_41Measurement_1_e7'), 'B2', plate)) %>%
  mutate(plate=ifelse((dir=='dC20264_B1__20200928T12_28_55Measurement_1_e5'), 'B1', plate)) %>%
  mutate(plate=ifelse((dir=='dW20267_A1__20201002T10_37_07Measurement_1_e5'), 'A1', plate)) %>%
  mutate(plate=ifelse((dir=='dW20267_A2__20201004T15_35_00Measurement_1_e5'), 'A2', plate)) %>%
  mutate(plate=ifelse((dir=='dW20267_B1__20201004T12_18_54Measurement_2_e5'), 'B1', plate)) %>%
  mutate(plate=ifelse((dir=='dW20267_B2__20201002T12_32_44Measurement_2_e5'), 'B2', plate)) %>%
   mutate(dir=ifelse((dir=='dC20255_B2_last3columns__20200928T09_33_41Measurement_1_e7'), 'dC20255_B2__20200926T13_00_37Measurement_2_e6', dir)) %>%
  mutate(dir=ifelse((dir=='dC20264_B1_last3__20200928T13_26_45Measurement_1_e5'), 'dC20264_B1__20200928T12_28_55Measurement_1_e5', dir)) %>%
  # hardcode mapped replicates to paired IDs
  # this throws an error
   mutate(group_pair = LETTERS702[group_indices(., substr(plate,1,1), sub("\\_.*", "", dir))]) 

rm(excludes, LETTERS702) #cleanup env
```

## Lookup information

```{r}
# Lookup stain information
# originally a google doc
feature_metadata <- read.csv('../../lookups/do/feature_metadata.csv')
# try({
#   feature_metadata <- googlesheets4::read_sheet(ss = "1A6qMVGhtJykfbCQK1qq0qv5w3HfKvs8ByVSCiExc49s", sheet = 'do_screen') 
# })
  # remove unmatched features from all_plates
  # this doesn't seem necessary for Founders but will need for DO
  harmony_collection$all_plates <- harmony_collection$all_plates %>% dplyr::select(-feature_metadata$name_[feature_metadata$mutuality==FALSE])

  # remove unmatched features from features metadata (if applicable)
harmony_collection$features_df <- harmony_collection$features_df %>%
  left_join(feature_metadata[,c("name_","stain","mutuality")], "name_") %>%
  filter(mutuality) %>% # TRUE/FALSE if in DO and vice versa
  dplyr::select(-mutuality)
# remove columns / features with pattern "stdev"
# removes from feature_df and all_plates
harmony_collection <- remove_sd_vars(harmony_collection)

# add technician lookup
tech_df <- read.csv("../../lookups/do/technician_lookup.csv")

harmony_collection$all_plates <- harmony_collection$all_plates %>%
  left_join(tech_df, by="dir")
```

# Data corrections

## Correlation sub-analysis for feature selection

```{r}
############ 1 ############
# scales all data between 0 and 100 into a new object
rescaled_data_list <- rescale_feature_df_0_100(harmony_collection$all_plates, covariates = c("dose","mouse"))

# ############ 2 ############
mouse_metrics <- mean_correlation_by_doseresponse(data = rescaled_data_list,  group_id = 'mouse')
# ############ 3 ############
# add completion NA %
results <- suppressWarnings(filter_exceedances(list_data = mouse_metrics, # input list object
                                               n = 50, # maximum number of values to return
                                               corr_cut_off = 0.6, # makes underlying values positive
                                               rank_by = 'stdev')) # this is the only current
```

## Initial data selection

```{r}
hoescht_features <- data.frame("feature" = c(
  "multi_nucleated_cells_numberofobjects", # similar
  "infocus_intensity_cell_hoechst_mean_mean", # similar
  "infocus_nucleus_hoechst_ser_dark_1px_mean", 
  "infocus_nucleus_hoechst_ser_edge_1px_mean", # similar
  ))

mitotracker_features <- data.frame("feature" = c(
  "nuclei_numberofobjects", # similar
  "infocus_intensity_cell_mitotrackerdeepred_mean_mean", # similar
  "infocus_cell_area_mm2_mean",
  "infocus_cell_mitotrackerdeepred_ser_edge_1px_mean" # similar
  ))
```

## Effects modeling & Pair-plate plotting

## Copy a dataset for analytics / experimental work

```{r}
features_selected <- c(hoescht_features$feature,mitotracker_features$feature)

harmony_collection$analytics_subset <- harmony_collection$all_plates[,c(c('run','dir','plate','row','column','dose','individual','mouse', 'group_pair'),features_selected)] %>%
  #filter(!is.na(mouse)) %>% # shouldn't need this
  mutate(findividual = factor(individual), 
         fplate_idx = factor(substrRight(plate,1)),
         fdose = factor(dose),
         fdir = factor(dir), 
         frow = factor(row), 
         fplate = factor(plate),
         fcolumn = factor(column)
         )
```

## Transformations

```{r}
# plot distributions raw
# 4 Mito / 4 Hoescht
Hmisc::hist.data.frame(harmony_collection$analytics_subset[,features_selected])

# log transformations
# custom transformations here
harmony_collection$analytics_subset[,paste0("log_",features_selected)] <- lapply(harmony_collection$analytics_subset[,features_selected], function(x) log(x))

Hmisc::hist.data.frame(harmony_collection$analytics_subset[,paste0("log_",features_selected)])

# rescale all to new range
harmony_collection$analytics_subset[,paste0("scaled_log_",features_selected)] <- lapply(harmony_collection$analytics_subset[,paste0("log_",features_selected)], function(x) scales::rescale(x, to = c(0.001, 99.999), from = range(x, na.rm = TRUE, finite = TRUE)))

Hmisc::hist.data.frame(harmony_collection$analytics_subset[,paste0("scaled_log_",features_selected)])

# Convert Inf / -Inf to NA 
harmony_collection$analytics_subset[is.na(harmony_collection$analytics_subset) | harmony_collection$analytics_subset == Inf | harmony_collection$analytics_subset == -Inf] <- NA 

# loop function for binary color scheme ggplot
# consider moving this to beginning
harmony_collection$analytics_subset <- iterate_bin_id(harmony_collection$analytics_subset)
```

## Baseline mixed effects 

## Custom functions

```{r}
# batch correction lme4 auto script
batch_correct <- function(formula_,feature, data, r.eff, target_col){
  pheno_raw <- data[,c(feature)]
  mn.pheno <- mean(pheno_raw, na.rm=TRUE)
  sd.pheno <- sd(pheno_raw, na.rm=TRUE)
  data$pheno <- (pheno_raw - mn.pheno) / sd.pheno
  fit <- lmer(formula_, data, REML=FALSE)
  random_effects <- ranef(fit)
  effects <- random_effects[[r.eff]]
  batch.ef <- effects[as.character(data[,c(target_col)][[1]]),]
  pheno_sub <- data$pheno - batch.ef
  pheno_adj <- (sd.pheno * pheno_sub) + mn.pheno
  return (pheno_adj)
}
```

### Model testing with lmerTest::step 

 - not part of pipeline / can skip

```{r}
try(rm(baseline,before, after, test))

# Set up control model
baseline <-lmer(multi_nucleated_cells_numberofobjects ~ (1|mouse) + (1|fdose) + (1|group_pair/dir), harmony_collection$analytics_subset, REML=FALSE)  # -7790 AIC # logLik 3914.4
# Experimental model
before <-lmer(multi_nucleated_cells_numberofobjects ~ (1|individual) + (1|fdose) + (1|group_pair/dir), harmony_collection$analytics_subset, REML=FALSE) 
# before <-lmer(log_mito_uniformity ~ fdose*fplate_idx*log_num_nuclei  + (1 | group_pair/dir) + (1|run), data=harmony_collection$analytics_subset) 
# before_test <- lmer(log_mito_uniformity ~ fdose * log_num_nuclei + (1 | group_pair/dir) +(1|plate)+ (dose | individual/mouse), harmony_collection$analytics_subset, REML=FALSE) # -7790 AIC # logLik 3914.4
# employs an LRT test
test <- lmerTest::step(
  before
  #,alpha.random = 0.05
  )
# generate LRT reduced model
after <- lmerTest::get_model(test)

# Compare 3 models 
#lmerTest::rand(after)
anova(baseline, before, after)
```

## Baseline correction on group_pair:dir / group_pair

- Runs generic batch formula per feature selected

```{r}
# formula currently in use
# pheno is swapped with the specific feature name
f_ <- formula(pheno ~ (1|mouse) + (1|fdose) + (1|group_pair/dir)) 
for (feature in paste0("scaled_log_",features_selected)){
 harmony_collection$analytics_subset[,paste0("corr1_",feature)]  <- batch_correct(formula_ = f_, feature, harmony_collection$analytics_subset, r.eff = 'dir:group_pair',target_col = 'dir')
}

Hmisc::hist.data.frame(harmony_collection$analytics_subset[,paste0("corr1_scaled_log_",features_selected)])
```

## Generate boxplot for paired plates (if wanted)

```{r}
setwd("../../")
boxplot_pairs(filename = 'output/boxplot_test_scale_nucleus_dark_before.pdf', 
              y ='scale_nucleus_dark',
              data = data)
boxplot_pairs(filename = 'output/boxplot_test_scale_nucleus_dark_after.pdf', 
              y ='check_nucleus_dark',
              data = data)
```

```{r}
### turned off

# data$check_log_mito_fluor_intensity <- batch_correct(formula_ = f_, 'check_log_mito_fluor_intensity', data, r.eff = 'group_pair',target_col = 'group_pair')
# model_results <- multi_process_v1(data = harmony_collection$analytics_subset,
#                                   formula_list = formula_list,
#                                   predictor = 'scale_log_mito_uniformity')
# # example output
# multi_process_predict(data = harmony_collection$analytics_subset,
#                       model_results = model_results,
#                       selected_model = 'nested_complex_k',
#                       group_pair = 'V',
#                       EC = 20)
```

# DRC generation

## Construct aggregate dataset for Dose-response fitting

```{r}
harmony_collection$drc_data <- harmony_collection$analytics_subset %>%
  group_by(individual, dose) %>%
  summarise_at(vars(c(
    features_selected,
    paste0("log_",features_selected),
    paste0("scaled_log_",features_selected),
    paste0("corr1_scaled_log_",features_selected)
    )), funs(m = mean(., na.rm = TRUE)))
```

## DRC overall curve

- places model inside list

```{r}
single_drc_list <- list()

for (feature in paste0("corr1_scaled_log_",features_selected,"_m")){
  print(feature)
  f_ <- formula(paste0(feature," ~ dose"))
  try({
    single_drc_list[[feature]] <- drc::drm(
      f_, 
      data = harmony_collection$drc_data,
      #separate = TRUE, # single fit does not need to be true
      type = 'continuous',
      fct = drc::LL2.4())
  })
}
```

```{r}
drc_to_ggplot_df <- function(m, df){
  # converts drc output to ggplotable df
  pl <- plot(m, xlab = "Dose (ppm)", ylab = "Response", 
        xlim=c(0, 5), log="", lwd=2, cex=1.2)
  names(pl) <- c("dose", "response")
  pl$Feature <- m$dataList$names$orName
  return (pl)
}

ggplot_list_ <- list()
for (model in single_drc_list){
  ggplot_list_[[model$dataList$names$orName]] <- drc_to_ggplot_df(model, harmony_collection$drc_data)
}

dr_curves <- do.call(rbind, ggplot_list_)

data_adj_stacked <- reshape2::melt(cbind(harmony_collection$drc_data[,c(grepl( "corr1" , names( harmony_collection$drc_data )))],harmony_collection$drc_data[,c("individual","dose")]), id.vars = c('dose','individual'))

ggplot(data= dr_curves, 
       mapping=aes(x=dose, y=response, group = Feature, color = Feature)
       ) + 
  geom_line(data=dr_curves, aes(x=dose, y = response)) +
  lims(y=c(0, 100), x = c(-.1,5.1)) +
small_font_theme + 
  scale_x_continuous(labels = unique(harmony_collection$drc_data$dose),
    breaks = unique(harmony_collection$drc_data$dose),
    # expand=expand_scale(mult = c(0.5, 2)),
     trans = trans_new("logpeps",
                 function(y) {
                   (y)^(1/2.3) 
                   },
                 function(x) {
                   (x)^(3)
                   },
                 domain=c(min(harmony_collection$drc_data$dose),Inf)
    ))+ 
  ggtitle("Average Dose Response Curve per DO mouse") +
  xlab("Arsenic Dose (ppm)") + ylab("Outcome Scaled") + theme(legend.position="right") + 
  geom_jitter(data = data_adj_stacked,
                 aes(x=dose, y=value, group=dose, color = variable, shape='.',ra.rm = TRUE), 
                 inherit.aes = FALSE,
                 ra.rm = TRUE,
              size = 0.3,
              show.legend = FALSE
               )#+ theme(legend.position="none")
```

## DRC per mouse fit

- separate == FALSE will decrease chances of convergence

```{r}
# need to add features_selected!
apply_drc_fit <- function(data,
                          features_selected,
                          form_name,
                          formula_,
                          separate,
                          type_){
  multi_drc_list <- list()
  test <- data  %>%
    group_by(individual)
  for (feature in paste0("corr1_scaled_log_",features_selected,"_m")){
    print(feature)
    f_ <- formula(paste0(feature," ~ dose"))
    try_fail <- "fail"
    
    try({
      multi_drc_list[[feature]] <- drc::drm(f_, data = test,
      separate = separate,
      curveid = individual,
      na.action = na.omit,
      type = type_,
      fct = formula_)
      try_fail <- "pass"
    })
  }
  return (multi_drc_list)
}
seek_drc_fit <- function(data, 
                         drc_success_lookup, 
                         seed_id, 
                         sample_n, 
                         separate,
                         type_, 
                         form_name, 
                         formula_){
  # generate log of samples, n 
  # find patterns of failure
  log_list <- list()
  multi_drc_list <- list()
  set.seed(seed_id)
  test <- data  %>%
    group_by(individual) %>%
    sample_n_groups(sample_n) 
for (feature in paste0("corr1_scaled_log_",features_selected,"_m")){
  
  print(feature)
  f_ <- formula(paste0(feature," ~ dose"))
  try_fail <- "fail"
  # look up best available
  sub_lu <- subset(drc_success_lookup, name == feature & n_samples == sample_n)

    try({
      multi_drc_list[[feature]] <- drc::drm(f_, data = test,
      separate = separate,
      curveid = individual,
      na.action = na.omit,
      type = type_,
      fct = formula_)
      try_fail <- "pass"
    })

    log_list[[feature]] <- list("pass" = try_fail,
                          "samples" = unique(test$individual),
                          "seed" = seed_id,
                          "separate" = separate,
                          "n_samples" = sample_n,
                          "formula" = form_name,
                          "type" = type_)
  
}
  qa_drc_sampling <- data.frame(
  
  "pass" = do.call("rbind", lapply(log_list, "[[", "pass")),
  "n_samples" = do.call("rbind", lapply(log_list, "[[", "n_samples")),
  "separate" = do.call("rbind", lapply(log_list, "[[", "separate")),
  "seed" = do.call("rbind", lapply(log_list, "[[", "seed")),
  "formula" = do.call("rbind", lapply(log_list, "[[", "formula")),
  "type" = do.call("rbind", lapply(log_list, "[[", "type")))

  qa_drc_sampling$name <- rownames(qa_drc_sampling)
  rownames(qa_drc_sampling) <- NULL
  return (qa_drc_sampling)
}

models_to_ec50s <- function (m_list){
    ed50s_ll2.4 <- lapply(m_list, function(m) as.data.frame(suppressWarnings(drc::ED(m,50, interval = "fls", lref = 0, uref = 5))))
  ed50s_extract_ll2.4 <- as.data.frame(do.call("cbind", lapply(ed50s_ll2.4, function(x) {x$Estimate})))
  
  # hacky
  # Convert Inf / -Inf to NA 
  ed50s_extract_ll2.4[is.na(ed50s_extract_ll2.4) | ed50s_extract_ll2.4 == Inf | ed50s_extract_ll2.4 == -Inf] <- NA 
  
  # Optional quality checking
  ed50s_extract_ll2.4[ed50s_extract_ll2.4 >= 5 | ed50s_extract_ll2.4 <= 0] <- NA 
  ed50s_extract_ll2.4$individual <- stringi::stri_sub(as.character(rownames(ed50s_ll2.4[[1]])),3,-4) 
  return (ed50s_extract_ll2.4)
}

# CAREFUL THIS WILL REWRITE CONVERGENCE MEMORY
drc_success_lookup <- data.frame(matrix(ncol = 7, nrow = 0))
colnames(drc_success_lookup) <-   c("name","pass","n_samples","separate","seed","formula","type")
```

## Evaluate model success

- preview drc_success_lookup

```{r}
fct_list <- list("LL2.4" = LL2.4, "LL.5"=LL.5, "LL.4"=LL.4)
type_list <- c("continuous")
for (j in 1:length(type_list)){
  for (i in 1:length(fct_list)){
    print(paste0("testing on ",type_list[j], " ", names(fct_list)[i]))
    qa_drc_sampling <- seek_drc_fit(data = harmony_collection$drc_data,
                 drc_success_lookup = drc_success_lookup,
                 seed_id = 4,
                 sample_n = length(unique(harmony_collection$drc_data$individual)),
                 separate = TRUE,
                 type_ = type_list[j], # Poisson or continuous
                 form_name = names(fct_list)[i],
                 formula_ = fct_list[[i]]() # LL.3, LL.4,LL.5,W1.4,W2.4
                 )
      # add successful models if parameters are new and model passed above
    drc_success_lookup <- distinct(rbind(drc_success_lookup,qa_drc_sampling[ qa_drc_sampling$pass == 'pass',]))
  }
}

# show current success / failure
table(drc_success_lookup$formula, drc_success_lookup$type)
```

## Apply fit

- universal application of ll2.4 log fit

- functionality not generic enough

```{r}
multi_drc_list_ll2.4 <- apply_drc_fit(
  harmony_collection$drc_data,
  features_selected, # just take all
  "LL2.4",
  fct_list[[1]](),
  separate = TRUE,
  type_ = 'continuous'
)

ed50s_extract_ll2.4 <- models_to_ec50s(multi_drc_list_ll2.4)
ed50s_extract_ll2.4_stacked <- reshape2::melt(ed50s_extract_ll2.4, id.vars = c('individual')) 
```

## Accumulate ED50s

- scatter plot


```{r}
quick_pca <- function(f_, data, title){
 
  theme<-theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_blank(),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.text.x=element_text(colour="black"),axis.text.y=element_text(colour="black"),axis.ticks=element_line(colour="black"),plot.margin=unit(c(1,1,1,1),"line"))

  handle_data <- na.omit(data)
  pca.a <- prcomp(f_, data = handle_data, scale=TRUE)
  df_out <- as.data.frame(pca.a$x)
  df_out$feature <- unique(handle_data$individual)
  df_out$as_dose_sensitivity <- handle_data$as_dose_sensitivity
   percentage <- round(pca.a$sdev / sum(pca.a$sdev) * 100, 2)
percentage <- paste( colnames(df_out), "(", paste( as.character(percentage), "%", ")", sep="") )
  ap1<-ggplot(df_out,aes(x=PC1,y=PC2,label=feature, color = as_dose_sensitivity))
  ap <- ap1 + geom_point(size = 0.2)+theme + xlab(percentage[1]) + ylab(percentage[2])+ geom_text(size=2)

  ap + ggtitle(title)
}

# sub <- subset(harmony_collection$analytics_subset, individual %in% 
#          unique(subset_n2$individual))
formula_pca <- formula("~ corr1_scaled_log_infocus_intensity_cell_hoechst_mean_mean_m + corr1_scaled_log_infocus_nucleus_hoechst_ser_edge_1px_mean_m + corr1_scaled_log_infocus_nucleus_hoechst_ser_dark_1px_mean_m + corr1_scaled_log_multi_nucleated_cells_numberofobjects_m + 
corr1_scaled_log_infocus_cell_area_mm2_mean_m+
corr1_scaled_log_nuclei_numberofobjects_m +
corr1_scaled_log_infocus_intensity_cell_mitotrackerdeepred_mean_mean_m +
corr1_scaled_log_infocus_cell_mitotrackerdeepred_ser_edge_1px_mean_m")

# bin by average sensitivity
ed50s_extract_ll2.4$as_dose_sensitivity <- NULL
ed50s_extract_ll2.4$as_dose_sensitivity <- cut(rowMeans(ed50s_extract_ll2.4[ ,!(colnames(ed50s_extract_ll2.4) == "individual")], na.rm = TRUE), 5) 


quick_pca(formula_pca, ed50s_extract_ll2.4, "Corrected EC50s colored by sensitivity")

```

### PCA on Ec50s

```{r}
# compare.pca.a <- prcomp(formula_pca, data = ed50s_mitotracker)
# 
# rownames(ed50s_mitotracker) <- stringi::stri_sub(ed50s_mitotracker$individual,3,-4) 
# a_p<-autoplot(compare.pca.a, title = 'raw',data = ed50s_mitotracker, , loadings = TRUE, labels.repel = T, labels.text = 'individual' , loadings.label = TRUE, shape = FALSE,label.size = 2,loadings.label.repel=T,loadings.label.size = 2) +  theme(legend.position = "none")
# a_p + ggtitle("EC50s Hoescht features with lme4 correction")

```

```{r}
# set.seed(13)
# medrc_subset_agg_i_10 <- harmony_collection$analytics_subset %>% group_by(group_pair) %>%
#   sample_n_groups(10) %>% 
#   group_by(dose,fdose,findividual,individual,fdir, group_pair) %>%
#   summarise(mean_scale_log_mito_area = mean(scale_log_mito_area, na.rm = TRUE)) %>%
#   group_by(fdir,individual,findividual) %>%
#   mutate(
#     # imputation -- needs refinement
#     mean_scale_log_mito_area = impute.mean(mean_scale_log_mito_area)
#   )

# ok? table(medrc_subset_agg_i_10$fdir,medrc_subset_agg_i_10$group_pair)

  # prelim_extraction <- medrc::metadrm(
  #   mean_scale_log_mito_area ~ dose,
  #   data = medrc_subset_agg_i_10,
  #   fct = LL.4(),
  #   ind = findividual, #CURVE
  #   cid2 = group_pair, #HERBID
  #   struct = "UN",
  #   method = "REML" # or REML
  # )

  #   prelim_extraction <- medrc::metadrm(
  #   mean_scale_log_mito_area ~ dose,
  #   data = medrc_subset_agg_i_10,
  #   fct = LL.4(),
  #   ind = findividual, #CURVE
  #   cid2 = fdir, #HERBID
  #   struct = "UN",
  #   method = "REML" # or REML
  # )
  # cmat <- matrix(coefficients(prelim_extraction), ncol=4)
  # m <- apply(cmat, 2, mean)
  # names(m) <- letters[2:5]
  # rmat <- t(apply(cmat, 1, function(x) x-m)) # random effect starting values
  # rownames(rmat) <- sort(unique(medrc_subset_agg_i_10$group_pair))
  # colnames(rmat) <- letters[2:5]
  # start_vec <- c(random_effects$dir)[[1]]

  # medrc.m.scale_log_mito_fluor_intensity <-medrm(
  #   mean_scale_log_mito_area ~ dose,
  #   data = medrc_subset_agg_i_10,
  #   #curveid= b + c + d + e~ findividual,#b ~ findividual, 
  #   fct = LL.4(),
  #   random = c + d ~ 1 | group_pair,
  #   # weights = varPower(),
  #   control = nlme::nlmeControl(
  #     tolerance = 0.1,
  #     pnlsTol = 1,
  #     msMaxIter = 2000
  #   ), start = list(
  #     fixed = m[c("b", "c", "d", "e")], 
  #     fdir = rmat
  #     )
  # )
  
 # medrc.m.scale_log_num_nuclei <-medrm(
 #    scale_log_num_nuclei ~ dose,
 #    data = subset_n2,
 #    fct = LL.4(),
 #    random = b + c + d + e ~ 1 | individual,
 #    control = nlme::nlmeControl(
 #      tolerance = 0.1,
 #      pnlsTol = 1,
 #      msMaxIter = 2000
 #    )
 #  )
 # 
 #  medrc.m.scale_log_mito_area <-medrm(
 #    scale_log_mito_area ~ dose,
 #    data = medrc_subset[!is.na(medrc_subset$scale_log_mito_area),],
 #    fct = LL.4(),
 #    random = b + c + d + e ~ 1 | individual,
 #    control = nlme::nlmeControl(
 #      tolerance = 0.1,
 #      pnlsTol = 1,
 #      msMaxIter = 2000
 #    )
 #  )
 #   medrc.m.scale_log_mito_uniformity <- medrm(
 #    scale_log_mito_uniformity ~ dose,
 #    data = medrc_subset[!is.na(medrc_subset$scale_log_mito_uniformity),],
 #    fct = LL.4(),
 #    random = b + c + d + e ~ 1 | individual,
 #    control = nlme::nlmeControl(
 #      tolerance = 0.1,
 #      pnlsTol = 1,
 #      msMaxIter = 2000
 #    )
 #  )
 #  medrc.m.scale_log_mito_fluor_intensity <-medrm(
 #    scale_log_mito_fluor_intensity ~ dose,
 #    data = medrc_subset[!is.na(medrc_subset$scale_log_mito_fluor_intensity),],
 #    fct = LL.4(),
 #    random = b + c + d + e ~ 1 | individual,
 #    control = nlme::nlmeControl(
 #      tolerance = 0.1,
 #      pnlsTol = 1,
 #      msMaxIter = 2000
 #    )
 #  )
 # level 3 mouse/dir/fdose
 # level 2 mouse/fdose
 
```

```{r}
# plot(medrc.m.scale_log_mito_fluor_intensity, logx=TRUE, ndose=25, ranef=TRUE) +  theme(legend.position = "none")
```

## PCA checks

- swap colors

```{r}
# check results
# random sample individual by plate
# data_pca <- data %>% drop_na() #%>% filter(group_pair %in% c('AH')) %>% drop_na() 
# random_ind <- subset(data_pca, group_pair %in% sample(data_pca$group_pair, 2))
# random_ind <- subset(random_ind, dose %in% sample(random_ind$dose, 1))
# compare.pca.a <- prcomp(random_ind[,c('log_num_nuclei','log_mito_uniformity','log_mito_fluor_intensity','log_mito_area')])
# compare.pca.b <- prcomp(random_ind[,c('check_log_num','check_log_mito_uniformity','check_log_mito_fluor_intensity','check_mito_area')])
# a_p<-autoplot(compare.pca.a, title = 'raw',data = random_ind, colour = 'dir', loadings = TRUE, loadings.label = TRUE, label.size = 3) +  theme(legend.position = "none")
# b_p<-autoplot(compare.pca.b, title = 'adj', data = random_ind, colour = 'dir', loadings = TRUE, loadings.label = TRUE, label.size = 3) + theme(legend.position = "none")
# figure <- ggarrange(a_p,b_p,ncol=2, labels = c("raw", "adj"))
# annotate_figure(figure, top = text_grob(paste(unique(random_ind$dose), "  ", unique(random_ind$group_pair))))
```

```{r}
### differences between plates on 2 group_pairs and a single dose

# set.seed(4)
# random_ind <- subset(data, group_pair %in% sample(data$group_pair, 2))
# random_ind <- subset(random_ind, dose %in% sample(random_ind$dose, 1))
# compare.pca.a <- prcomp(random_ind[,c('log_num_nuclei','log_mito_uniformity','log_mito_fluor_intensity','log_mito_area')], scale = TRUE)
# compare.pca.b <- prcomp(random_ind[,c('check_log_num','check_log_mito_uniformity','check_log_mito_fluor_intensity','check_mito_area')], scale = TRUE)
# a_p<-autoplot(compare.pca.a, title = 'raw',data = random_ind, colour = 'individual', loadings = TRUE, loadings.label = TRUE, label.size = 3) +  theme(legend.position = "none")
# b_p<-autoplot(compare.pca.b, title = 'adj', data = random_ind, colour = 'individual', loadings = TRUE, loadings.label = TRUE, label.size = 3) + theme(legend.position = "none")
# figure <- ggarrange(a_p,b_p,ncol=2, labels = c("raw", "adj"))
# annotate_figure(figure, top = text_grob(paste(unique(random_ind$dose), "  ", paste0(unique(random_ind$group_pair[1]))," ",unique(random_ind$group_pair)[2])))
```

- check this
https://stackoverflow.com/questions/36780357/plotting-dose-response-curves-with-ggplot2-and-drc/37043751
# https://rpsychologist.com/r-guide-longitudinal-lme-lmer#partially-nested-models
# consider https://ourcodingclub.github.io/tutorials/mixed-models/
# https://stats.stackexchange.com/questions/228800/crossed-vs-nested-random-effects-how-do-they-differ-and-how-are-they-specified



```{r}
# m <- lme4::lmer(formula_list[[4]], data = harmony_collection$analytics_subset, REML = FALSE)
# 
# plot(m, which = 1)

# baseline_me_model_log_mito_m2_lmer <- nlme::lme(log_mito_uniformity ~ fdose, random = ~1|plate/individual, data=harmony_collection$analytics_subset,
#         na.action = na.omit)

# nlme example
# baseline_me_model_log_mito <- lme(log_mito_uniformity ~ 1, random = ~ plate | individual data=harmony_collection$analytics_subset)

# apply ranef
# 4 evaluation scripts
# anova(baseline_me_model_log_mito_m2_lmer)
# anova(baseline_me_model_log_mito_m2)
# 
# lme4::ranef(baseline_me_model_log_mito_m2_lmer)
# 
# 
# lme4::ranef(baseline_me_model_log_mito_m2)
# 
# lme4::fixef(baseline_me_model_log_mito)
#anova(baseline_me_model)
#ranova(baseline_me_model)
```


## Save/overwrite

### RDS object

```{r}
print(paste0("temp_files/",selected_dir,'_processed.RData'))
temp_data_storage <- paste0("temp_files/",selected_dir,'_processed.RData')
saveRDS(harmony_collection, temp_data_storage)
```

### Platemap object

- improve and move this to scripts

```{r}
generate_platemap <- function(df){
  # creates data useable with platetools functions
  df <- df %>%
    mutate(row = toupper(letters[row]),
           column = sprintf("%02d", column),
           dose = as.character(dose),
           ) %>%
    mutate(well = paste0(row,column)) %>%
    select_('well','plate','individual','dose', 'group_pair','bin_id') %>%
    group_by(plate) %>%
    group_split()  #%>%
  list_names <- paste0(sapply(df, function(x) unique(x$group_pair)),"_",sapply(df, function(x) unique(as.integer(as.logical(x$bin_id))+1)))
  names(df) <- list_names
  return (df)
}

plot_platemap <- function(df, headings, feature_symbol, output_dir){
  tryCatch(
      {
         p<-platetools::raw_map(
              well = df$well,
              data = df$individual,
                plate = 96)+
                ggtitle(paste0(headings," pair"),
                        subtitle = paste0('directory: ',unique(df$plate))) +
              shadowtext::geom_shadowtext(aes(
                label = paste0(df$dose),
                ),
                size = 4,
                show.legend  = F,
                fontface = "bold"
                ) 
            pdf(file =  paste0(output_dir, "/",headings,".pdf"))
            plot(p)
            dev.off()
      },
      error=function(error_message) {
          message(error_message)
          return(NA)
      }
  )
}

# platemaps_do <- generate_platemap(harmony_collection$analytics_subset)
# dir.create('./output/do_screen')
# for (i in 1:length(platemaps_do)){
#   plot_platemap(platemaps_do[[i]], 
#                 headings = paste0("do_screen_", names(platemaps_do)[i]), 
#                 feature_symbol = "dose",
#                 output_dir = './output/do_screen')
# }
```

### Write QC csv

```{r}
# harmony_collection$all_plates[,c(c('dir','row','column','dose','individual','mouse', 'group_pair'),features_of_interest$feature)] %>%
#   write_csv("output/qa_subset.csv")
```

---

- __Continue this pipeline using the _processed.RData_ dataset__