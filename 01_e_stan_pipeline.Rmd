---
title: "DO #1a LMER custom test"
author:
- name: Robert Sellers
  affiliation: The Jackson Laboratory
date: "`r paste('Last knit on:',format(Sys.time(), '%d %B %Y'))`"
abstract: |
latex_engine: pdflatex
output:
  html_document:
    fig_caption: yes
    force_captions: yes
    number_sections: true
    theme: lumen
    toc: yes
    toc_float: yes
    df_print: paged
    # code_folding: "hide"
  pdf_document:
    fig_caption: yes
    force_captions: yes
    highlight: pyments
    keep_tex: yes
    latex_engine: xelatex
    number_sections: no
    toc: no
    
---

# Programming environment

```{r message=FALSE}
options(scipen = 999)
library(dplyr)
library(ggplot2)
library(standrc)
library(robustbase)
library(scales)
source('scripts/standrc_evals.R') # standrc code that actually works
source('scripts/custom_tools.R')
source("scripts/harmony_utils.R")
```

# Data setup

- groups / effects are coerced as integers to appease standrc code

```{r}
setwd("/Users/seller/Desktop/projects/jax_arsenic_toxicology_analysis")
harmony_collection <- readRDS("temp_files/do_focus_merge_2_forstan.RData")
feature_subset <- harmony_collection$analytics_subset %>%
  group_by(dir) %>%
  mutate(dir_id = cur_group_id()) %>%
  group_by(individual) %>%
  mutate(individual_id = cur_group_id())
```

1. Isolate "useful" features

a. remove high missing rates

```{r}
# nothing right now
# need to change harmony object loading system to update single object based on directory
```

2. Select 8 variables
  - 4 hoescht / 4 mitotracker currently
  
```{r}
# multi_nucleated_cells_numberofobjects, infocus_intensity_cell_hoechst_mean_mean, infocus_nucleus_hoechst_ser_edge_1px_mean, infocus_nucleus_hoechst_ser_dark_1px_mean
# infocus_intensity_cell_mitotrackerdeepred_mean_mean, nuclei_numberofobjects, infocus_cell_mitotrackerdeepred_ser_edge_1px_mean, infocus_cell_area_mm2_mean

```

# Modeling

3. Run Stan model on each
  - extract ed50 and respective predictions per value
  - generate scatterplot (x/y) and highlight high variance

## Subsets

```{r}
stan_df_hoescht_multinucleatedobjects <- prepare_data_for_stan('multi_nucleated_cells_numberofobjects',
                                        feature_subset, 
                                        log_ = FALSE)
stan_df_hoescht_intensity <- prepare_data_for_stan('infocus_intensity_cell_hoechst_mean_mean',
                                        feature_subset, 
                                        log_ = FALSE)
stan_prep_hoescht_edge <- prepare_data_for_stan('infocus_nucleus_hoechst_ser_edge_1px_mean',
                                        feature_subset, 
                                        log_ = FALSE)
stan_prep_hoescht_dark <- prepare_data_for_stan('infocus_nucleus_hoechst_ser_dark_1px_mean',
                                        feature_subset, 
                                        log_ = FALSE)
stan_prep_mito_intensity <- prepare_data_for_stan('infocus_intensity_cell_mitotrackerdeepred_mean_mean',
                                        feature_subset, 
                                        log_ = FALSE)
stan_prep_mito_nucleinumberofobjects <- prepare_data_for_stan('nuclei_numberofobjects',
                                        feature_subset, 
                                        log_ = FALSE)
stan_prep_mito_edge <- prepare_data_for_stan('infocus_cell_mitotrackerdeepred_ser_edge_1px_mean',
                                        feature_subset, 
                                        log_ = FALSE)
stan_prep_mito_area <- prepare_data_for_stan('infocus_cell_area_mm2_mean',
                                        feature_subset, 
                                        log_ = FALSE)
```

## Stan code

```{r}
spm_hoescht_multinucleatedobjects <- standrm_harmony(formula=response ~ dose, data = stan_df_hoescht_multinucleatedobjects, 
                            fct = LL.4(), # slope, lower limit, upper limit, ed50
                            curveid= b + e ~ individual_id,
                            standrc_priors(e="normal(pe, 5)", b="normal(pb, 1)"), 
                            random=b + c + d  ~ dir_id
                            )
spm_hoescht_intensity<- standrm_harmony(formula=response ~ dose, data=stan_df_hoescht_intensity, 
                            fct = LL.4(), # slope, lower limit, upper limit, ed50
                            curveid= b + e ~ individual_id,
                            standrc_priors(e="normal(pe, 5)", b="normal(pb, 1)"), 
                            random=b + c + d  ~ dir_id
                            )
spm_hoescht_edge <- standrm_harmony(formula=response ~ dose, data=stan_prep_hoescht_edge, 
                            fct = LL.4(), # slope, lower limit, upper limit, ed50
                            curveid= b + e ~ individual_id,
                            standrc_priors(e="normal(pe, 5)", b="normal(pb, 1)"), 
                            random=b + c + d  ~ dir_id
                            )
spm_hoescht_dark <- standrm_harmony(formula=response ~ dose, data=stan_prep_hoescht_dark, 
                            fct = LL.4(), # slope, lower limit, upper limit, ed50
                            curveid= b + e ~ individual_id,
                            standrc_priors(e="normal(pe, 5)", b="normal(pb, 1)"), 
                            random=b + c + d  ~ dir_id
                            )
spm_mito_intensity <- standrm_harmony(formula=response ~ dose, data=stan_prep_mito_intensity, 
                            fct = LL.4(), # slope, lower limit, upper limit, ed50
                            curveid= b + e ~ individual_id,
                            standrc_priors(e="normal(pe, 5)", b="normal(pb, 1)"), 
                            random=b + c + d  ~ dir_id
                            )
spm_mito_nucleinumberofobjects <- standrm_harmony(formula=response ~ dose, data=stan_prep_mito_nucleinumberofobjects, 
                            fct = LL.4(), # slope, lower limit, upper limit, ed50
                            curveid= b + e ~ individual_id,
                            standrc_priors(e="normal(pe, 5)", b="normal(pb, 1)"), 
                            random=b + c + d  ~ dir_id
                            )
spm_mito_edge <- standrm_harmony(formula=response ~ dose, data=stan_prep_mito_edge, 
                            fct = LL.4(), # slope, lower limit, upper limit, ed50
                            curveid= b + e ~ individual_id,
                            standrc_priors(e="normal(pe, 5)", b="normal(pb, 1)"), 
                            random=b + c + d  ~ dir_id
                            )
spm_mito_area <- standrm_harmony(formula=response ~ dose, data=stan_prep_mito_area, 
                            fct = LL.4(), # slope, lower limit, upper limit, ed50
                            curveid= b + e ~ individual_id,
                            standrc_priors(e="normal(pe, 5)", b="normal(pb, 1)"), 
                            random=b + c + d  ~ dir_id
                            )
```

4. Extract
  - remove outlier ed50s?
  - rescaling inappropriate?
  - selecting based on general sensitivity and/or resilience
  
```{r}
ed50_hoescht_multinucleatedobjects <- ED(spm_hoescht_multinucleatedobjects, respLev=c(50))
ed50_hoescht_intensity <- ED(spm_hoescht_intensity, respLev=c(50))
ed50_hoescht_edge <- ED(spm_hoescht_edge, respLev=c(50))
ed50_hoescht_dark <- ED(spm_hoescht_dark, respLev=c(50))
ed50_mito_intensity <- ED(spm_mito_intensity, respLev=c(50))
ed50_mito_nucleinumberofobjects <- ED(spm_mito_nucleinumberofobjects, respLev=c(50))
ed50_mito_edge <- ED(spm_mito_edge, respLev=c(50))
ed50_mito_area <- ED(spm_mito_area, respLev=c(50))
ed50s_df_hoescht <- data.frame(
  "individual" = unique(feature_subset$individual), # confirm this is correct order
  "hoescht_multinucleatedobjects" = colMedians(ed50_hoescht_multinucleatedobjects$`50`),
  "hoescht_intensity" = colMedians(ed50_hoescht_intensity$`50`),
  "hoescht_edge" = colMedians(ed50_hoescht_edge$`50`),
  "hoescht_dark" = colMedians(ed50_hoescht_dark$`50`)
  )

ed50s_df_mito <- data.frame(
  "individual" = unique(feature_subset$individual), # confirm this is correct order
  "mito_intensity" = colMedians(ed50_mito_intensity$`50`),
  "mito_nucleinumberofobjects" = colMedians(ed50_mito_nucleinumberofobjects$`50`),
  "mito_edge" = colMedians(ed50_mito_edge$`50`),
  "mito_area" = colMedians(ed50_mito_area$`50`)
)
ed50s_df_hoescht$mean_row <- rowMeans(ed50s_df_hoescht[ ,-1])
ed50s_df_mito$mean_row <- rowMeans(ed50s_df_mito[ ,-1])
hist(ed50s_df_hoescht$mean_row)
hist(ed50s_df_mito$mean_row)
sensitive_hoescht <- ed50s_df_hoescht %>% slice_min(mean_row, n = 1) 
resilient_hoescht <- ed50s_df_hoescht %>% slice_max(mean_row, n = 1) 
sensitive_mito <- ed50s_df_mito %>% slice_min(mean_row, n = 1) 
resilient_mito <- ed50s_df_mito %>% slice_max(mean_row, n = 1) 
```



```{r}
pm_hoescht_multinucleatedobjects <- predict_harmony(spm_hoescht_multinucleatedobjects, newdata = data.frame("individual_id" = unique(feature_subset$individual_id), "dose" = ed50s_df_hoescht$hoescht_multinucleatedobjects))
pm_hoescht_intensity <- predict_harmony(spm_hoescht_intensity, newdata = data.frame("individual_id" = unique(feature_subset$individual_id), "dose" = ed50s_df_hoescht$hoescht_intensity))
pm_hoescht_edge <- predict_harmony(spm_hoescht_edge, newdata = data.frame("individual_id" = unique(feature_subset$individual_id), "dose" = ed50s_df_hoescht$hoescht_edge))
pm_hoescht_dark <- predict_harmony(spm_hoescht_dark, newdata = data.frame("individual_id" = unique(feature_subset$individual_id), "dose" = ed50s_df_hoescht$hoescht_dark))
pm_mito_intensity <- predict_harmony(spm_mito_intensity, newdata = data.frame("individual_id" = unique(feature_subset$individual_id), "dose" = ed50s_df_mito$mito_intensity))
pm_mito_nucleinumberofobjects <- predict_harmony(spm_mito_nucleinumberofobjects, newdata = data.frame("individual_id" = unique(feature_subset$individual_id), "dose" = ed50s_df_mito$mito_nucleinumberofobjects))
pm_mito_edge <- predict_harmony(spm_mito_edge, newdata = data.frame("individual_id" = unique(feature_subset$individual_id), "dose" = ed50s_df_mito$mito_edge))
pm_mito_area <- predict_harmony(spm_mito_area, newdata = data.frame("individual_id" = unique(feature_subset$individual_id), "dose" = ed50s_df_mito$mito_area))

predictions <- data.frame("individual" = unique(feature_subset$individual))
predictions$hoescht_multinucleatedobjects <- apply(pm_hoescht_multinucleatedobjects, 2, function(x) mean(x, na.rm=TRUE))
predictions$hoescht_intensity <- apply(pm_hoescht_intensity, 2, function(x) mean(x, na.rm=TRUE))
predictions$hoescht_edge <- apply(pm_hoescht_edge, 2, function(x) mean(x, na.rm=TRUE))
predictions$hoescht_dark <- apply(pm_hoescht_dark, 2, function(x) mean(x, na.rm=TRUE))
predictions$mito_intensity <- apply(pm_mito_intensity, 2, function(x) mean(x, na.rm=TRUE))
predictions$mito_nucleinumberofobjects <- apply(pm_mito_nucleinumberofobjects, 2, function(x) mean(x, na.rm=TRUE))
predictions$mito_edge <- apply(pm_mito_edge, 2, function(x) mean(x, na.rm=TRUE))
predictions$mito_area <- apply(pm_mito_area, 2, function(x) mean(x, na.rm=TRUE))
```

- rbind all predictions, ed50s, and groups

```{r}
pred_long <- predictions %>% 
    tidyr::gather(feature, value, -individual)

pred_mito_ed_long <- ed50s_df_mito %>% 
    dplyr::select(-last_col()) %>%
    tidyr::gather(feature, value, -individual)

pred_hoescht_ed_long <- ed50s_df_hoescht %>% 
    dplyr::select(-last_col()) %>%
    tidyr::gather(feature, value, -individual)

pred_ed_long_all <- rbind(pred_mito_ed_long,pred_hoescht_ed_long)
# ed_w_pred_df <- cbind(pred_long,pred_ed_long_all)
pred_ed_long_all_join <- pred_ed_long_all %>% right_join(pred_long, by=c("individual","feature"))
colnames(pred_ed_long_all_join) <- c("individual","feature","ed50_dose", "pred_response")
```

```{r}
# plot groups
# intensity_sub 
# count_sub 
# edge_sub 

# sensitive_hoescht <- ed50s_df_hoescht %>% slice_min(mean_row, n = 3) 
# resilient_hoescht <- ed50s_df_hoescht %>% slice_max(mean_row, n = 3) 
# sensitive_mito <- ed50s_df_mito %>% slice_min(mean_row, n = 3) 
# resilient_mito <- ed50s_df_mito %>% slice_max(mean_row, n = 3) 

sensitive_features <- subset(pred_ed_long_all_join, individual %in% c(sensitive_hoescht$individual, sensitive_mito$individual))

resilient_features <- subset(pred_ed_long_all_join, individual %in% c( resilient_hoescht$individual, resilient_mito$individual))
```

```{r}
ggplot(pred_ed_long_all_join) +
   geom_point(mapping = aes(x = ed50_dose, y = pred_response, 
                          color = feature), size = 0.5) + 
  # geom_text(data = sensitive_features, aes(x = ed50_dose, y = pred_response, label = individual), size = 2, color = 'blue') +
  # geom_text(data = resilient_features, aes(x = ed50_dose, y = pred_response, label = individual), size = 2, color = 'darkred') +
  geom_line(data = sensitive_features,aes(x = ed50_dose, y = pred_response, group = individual), color = 'blue') +
  geom_line(data = resilient_features,aes(x = ed50_dose, y = pred_response, group = individual), color = 'darkred') +
    ggrepel::geom_text_repel(aes(x=ed50_dose, y=pred_response,label = individual),
                             data = resilient_features,
                 nudge_x = 2,
                 color = 'darkred',
               bg.color = "white",
                  bg.r = 0.25,
               force = 2,
               size = 2) +
    ggrepel::geom_text_repel(aes(x=ed50_dose, y=pred_response,label = individual),
                             data = sensitive_features,
                 #nudge_x = 2,
                 force = 2,
               bg.color = "white",
               color = "darkblue",
                  bg.r = 0.25,
               size = 2)
```
