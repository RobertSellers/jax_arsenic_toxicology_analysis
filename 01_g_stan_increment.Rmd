---
title: "DO #1g stan incremental analysis"
author:
- name: Robert Sellers
  affiliation: The Jackson Laboratory
date: "`r paste('Last knit on:',format(Sys.time(), '%d %B %Y'))`"
abstract: |
latex_engine: pdflatex
output:
  html_document:
    fig_caption: yes
    force_captions: yes
    number_sections: true
    theme: lumen
    toc: yes
    toc_float: yes
    df_print: paged
    # code_folding: "hide"
  pdf_document:
    fig_caption: yes
    force_captions: yes
    highlight: pyments
    keep_tex: yes
    latex_engine: xelatex
    number_sections: no
    toc: no
    
---
```{r}
# point to parent data directory
setwd("data/invitro/")
selected_dir <- "./do_focus_merge_2"
# Warning - this currently expects a temp_files data dir 
# Set overwrite to TRUE when underlying data dir has been changed
harmony_collection <- harmony_create_collection(dir = selected_dir, overwrite = FALSE)

# env
options(scipen = 999) # suppress sci notation

# contains harmony plate collection class builder
source("scripts/harmony_utils.R")
# various add-on scripts and stats tools
source("scripts/custom_tools.R")
# standrc code that actually works
source('scripts/standrc_evals.R')

library(rstan)
```

```{r}
# function for https://benchmarkdose.org/
# garbage
benchmark_save <- function(data){
  data <- data %>%
    group_by(individual_id) %>%
    sample_n_groups(7) %>%
    mutate(individual_id = cur_group_id()-1) %>%
    arrange(dose,individual_id,response)
  # benchmark_save(feature_subset)
  data$dose[data$dose == 0] <- 0.001

  write.table(data.frame("Dose" = data$dose, "Individual" = data$individual_id, "Response" = as.integer(data$response)), "~/Desktop/example.tsv",sep = '\t', row.names = F,quote = FALSE)
}
#benchmark_save(feature_subset)
```
- https://discourse.mc-stan.org/t/fitting-a-non-linear-growth-model-with-stan/4246
- https://www.magesblog.com/post/2015-11-03-loss-developments-via-growth-curves-and/


```{r}
plot_posterior_growth_ci <- function(fit, dat){
  Y_mean <- extract(fit, "Y_mean")
  Y_mean_cred <- apply(Y_mean$Y_mean, 2, quantile, c(0.05, 0.95))
  Y_mean_mean <- apply(Y_mean$Y_mean, 2, mean)
  
  Y_pred <- extract(fit, "Y_pred")
  Y_pred_cred <- apply(Y_pred$Y_pred, 2, quantile, c(0.05, 0.95))
  Y_pred_mean <- apply(Y_pred$Y_pred, 2, mean)
  plot(dat$Y ~ dat$x, xlab="x", ylab="Y", 
     ylim=c(-1, 101), main="Non-linear Growth Curve")
  lines(dat$x, Y_mean_mean)
  points(dat$x, Y_pred_mean, pch=19)
  lines(dat$x, Y_mean_cred[1,], col=4)
  lines(dat$x, Y_mean_cred[2,], col=4)
  lines(dat$x, Y_pred_cred[1,], col=2)
  lines(dat$x, Y_pred_cred[2,], col=2)
  legend(x="bottomright", bty="n", lwd=2, lty=c(NA, NA, 1, 1,1),
         legend=c("observation", "prediction", "mean prediction",
                  "90% mean cred. interval", "90% pred. cred. interval"),
         col=c(1,1,1,4,2),  pch=c(1, 19, NA, NA, NA))
}
```

Model 1: y = a with a > 0

Model 2: y = a exp(x/b) with a > 0

Model 3: y = a exp(±(x/b)d) with a > 0, b > 0, d ≥ 1

Model 4: y = a [c – (c – 1) exp(−x/b)] with a > 0, b > 0, c > 0

Model 5: y = a [c – (c – 1) exp(−(x/b)d)] with a > 0, b > 0, c > 0, d ≥ 1 where y is any

### Original growth model

```{r}
feature_subset <- harmony_collection$all_plates %>%
  group_by(dir) %>%
  mutate(dir_id = cur_group_id()) %>%
  group_by(individual) %>%
  mutate(individual_id = cur_group_id())


feature_subset <- prepare_data_for_stan('infocus_nucleus_hoechst_ser_dark_1px_mean',
                                        feature_subset, 
                                        log_ = FALSE)


feature_subset_2 <- arrange(feature_subset, dose)   %>%
  group_by(individual_id) %>%
  select(individual_id, response, dose, mouse) %>% 
  rename(Y = response, x = dose) 

# slope_test <- feature_subset_2 %>% 
#   group_by(individual_id) %>% 
#   nest() %>% 
#   mutate(model = map(data, ~ lm(Y ~ 1 + x, data = .x) %>% tidy)) %>% 
#   unnest(model) %>% 
#   filter(term == 'x')

dat <- list(
  "N" = nrow(feature_subset_2),  
  "x" = feature_subset_2$x,
  "Y" = feature_subset_2$Y,
  "pb" = 0,
  "pc" = 100,
  "pd" = 0.01,
  "pe" = 0.75,
  "pf" = 0)

stanmodel <- "
functions {
  real LL4(real x, real slope, real lasy, real uasy, real ed) {
    return lasy  + ( uasy - lasy ) / (1 + exp(-exp( slope ) * (log(x/ ed ))))^exp( 0 );
  }
  real LL4_test(real x, real slope){
    return (1-exp(-slope*x));
  }
  real growthFunction(real x, real a, real b, real lambda){
    return a - b * pow(lambda, x);
  }
  real posteriorDistributionOfMean(real x, real a, real b, real lambda){
    return a - b * pow(lambda, x);
  }
}
data {
  int<lower=0> N; 
  real<lower=0> x[N];
  real Y[N]; 
  // from standrc
  real pb; 
  real pc; 
  real pd; 
  real pe;
} 
parameters {
  real a;
  real b;
  real<lower=.5,upper= 1> lambda; // original gamma in the JAGS example  
  real<lower=0> tau; 
  // from standrc
  real<lower=0> ed;
  real<lower=0> sigmasq_y;
  real slope; 
  real lasy; 
  real uasy; 
} 
transformed parameters {
  real<lower=0> sigma_y;
  //real sigma; 
  real mu[N];
  real mu2[N];
  sigma_y <- sqrt(sigmasq_y); 
  for (i in 1:N){
    mu[i] = growthFunction(x[i], a, b, lambda);
    //mu2[i] = LL4(x[i], slope, lasy, uasy, ed);
    mu2[i] = LL4_test(x[i], slope);
  }
  //sigma = 1 / sqrt(tau); 
} 
model {
  // priors
  //slope ~ normal(pb, 100) ; 
  //lasy ~ normal(pc, 100) ; 
  //uasy ~ normal(pd, 100) ; 
  //ed ~ normal(pe, 100) ;
  sigmasq_y ~ inv_gamma(0.001, 0.001) ; 
  a ~ normal(0.0, 1000); 
  b ~ normal(0.0, 1000); 
  lambda ~ uniform(.5, 1); 
  tau ~ gamma(.0001, .0001); 
  // likelihood function
  Y ~ normal(mu, sigma_y);   
  //Y ~ normal(mu, sigma);   
}
generated quantities{
  real residuals[N];
  //real log_lik[N];
  real Y_mean[N]; 
  real Y_pred[N]; 
  for(i in 1:N){
    Y_mean[i] = posteriorDistributionOfMean(x[i], a, b, lambda);
    // Posterior predictive distribution
    Y_pred[i] = normal_rng(Y_mean[i], sigma_y);    
    residuals[i] <- Y[i] - mu[i];
    //log_lik[i] <- normal_log(Y[i], mu[i], sigma_y);
    }
}
"
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
fit <- stan(model_code = stanmodel, 
            model_name = "GrowthCurve", 
            data = dat,
            chains = 4)

# baseline model
#print(fit, c("alpha", "beta", "lambda", "sigma"))
 traceplot(fit, pars=c("a","b","lambda","tau", "sigma_y"))
# trankplot(fit, pars=c("a","b","lambda","tau", "sigma"))
 precis(fit, pars=c("a","b","lambda","tau", "sigma"))
plot_posterior_growth_ci(fit,dat)
```
# parameter fits
## 1 parameter

 https://academic.oup.com/toxsci/article/66/2/298/1734199

```{r}
# baseline model
#print(fit, c("alpha", "beta", "lambda", "sigma"))
traceplot(fit, pars=c("alpha","beta","lambda","tau", "sigma"))
trankplot(fit, pars=c("alpha","beta","lambda","tau", "sigma"))
precis(fit, pars=c("alpha","beta","lambda","tau", "sigma"))
plot_posterior_growth_ci(fit,dat)
```
