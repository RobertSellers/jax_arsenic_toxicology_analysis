---
title: "DO #1f consolidated v1"
author:
- name: Robert Sellers
  affiliation: The Jackson Laboratory
date: "`r paste('Last knit on:',format(Sys.time(), '%d %B %Y'))`"
abstract: |
latex_engine: pdflatex
output:
  html_document:
    fig_caption: yes
    force_captions: yes
    number_sections: true
    theme: lumen
    toc: yes
    toc_float: yes
    df_print: paged
    # code_folding: "hide"
  pdf_document:
    fig_caption: yes
    force_captions: yes
    highlight: pyments
    keep_tex: yes
    latex_engine: xelatex
    number_sections: no
    toc: no
    
---

# Programming environment

```{r}
setwd("/Users/seller/Desktop/projects/jax_arsenic_toxicology_analysis")

# env
options(scipen = 999) # suppress sci notation

# contains harmony plate collection class builder
source("scripts/harmony_utils.R")
# various add-on scripts and stats tools
source("scripts/custom_tools.R")
# standrc code that actually works
source('scripts/standrc_evals.R')

library(tidyverse)
library(janitor)
library(ggplot2) 
library(ggfortify)
library(ggpubr)
library(lme4)
library(lmerTest)
library(sjPlot)
library(nlme)
library(dplyr)
library(standrc)
library(robustbase)
library(scales)
library(tibble)
library(broom)
library(plotly)
library(sqldf)
```

# Data setup

- recontruct initial data fixes to overwrite tempfile

```{r}
# point to parent data directory
setwd("data/invitro/")
selected_dir <- "./do_focus_merge_2"
# Warning - this currently expects a temp_files data dir 
# Set overwrite to TRUE when underlying data dir has been changed
harmony_collection <- harmony_create_collection(dir = selected_dir, overwrite = FALSE)
```

# Batch corrections

- control group 0 concentration (tbd)
- plate to plate (with lme4 or stan)

```{r}
# 
```

```{r}
# setwd("../analyses")
# callan_meansum_log <- readRDS('infocus_meansum_log.RDS')
# callan_log_dark <- subset(callan_meansum_log, outcome == 'infocus_nucleus_hoechst_ser_dark_1px_mean')[,c("individual","EC_50")]
```

# Analytics data construction

```{r}
feature_subset <- harmony_collection$all_plates %>%
  mutate(fdose=factor(dose)) %>%
  group_by(dir) %>%
  mutate(dir_id = cur_group_id()) %>%
  group_by(individual) %>%
  mutate(individual_id = cur_group_id())
```

# Dose response evaluation

```{r}
prepare_ed50s_stan <- function(model_, original_data){
  ed50_stan <- ED(model_, respLev=c(50))
  df = data.frame("individual_id" = sort(unique(original_data$individual_id)), "dose" = colMedians(ed50_stan$`50`))
  pred_stan <- predict_harmony(model_, newdata = df)
    df <- df %>% 
  rename(
    ed50 = dose
    )
  df$pred <- apply(pred_stan, 2, function(x) mean(x, na.rm=TRUE))
  df$group <- "stan"
  df$individual_id <- as.character(df$individual_id)
  return (df)
}

prepare_ed50s_drc <- function(model_, original_data){
  ed50_drc <- as.data.frame(drc::ED(model_, 50))
ed50_drc$individual <- str_match(rownames(ed50_drc), ":\\s*(.*?)\\s*:")[,2]
  # this might be a problem
  df = data.frame("individual_id" = as.character(ed50_drc$individual), "dose" = ed50_drc$Estimate)
  df$pred <- predict(model_, data.frame(
    dose = ed50_drc$Estimate,
    individual_id = str_match(rownames(ed50_drc), ":\\s*(.*?)\\s*:")[,2]
  ))
  df$group <- "drc"
  df$ed50 <- df$dose
  df$dose <- NULL
  return (df)
}

# batch correction lme4 auto script
batch_correct <- function(formula_,feature, data, r.eff, target_col, debug = FALSE){
  if (debug) browser()
  pheno_raw <- as.numeric(unlist(data[,c(feature)]))
  mn.pheno <- mean(pheno_raw, na.rm=TRUE)
  sd.pheno <- sd(pheno_raw, na.rm=TRUE)
  data$pheno <- (pheno_raw - mn.pheno) / sd.pheno
  fit <- lmer(formula_, data, REML=FALSE)
  random_effects <- ranef(fit)
  effects <- random_effects[[r.eff]]
  batch.ef <- effects[as.character(data[,c(target_col)][[1]]),]
  pheno_sub <- data$pheno - batch.ef
  pheno_adj <- (sd.pheno * pheno_sub) + mn.pheno
  return (pheno_adj)
}

# returns individual id to original value
map_do_to_original <- function(df_new, df_org){
  lookup_df <- df_org[,c('individual','individual_id')]
  return(plyr::join(df_new, distinct(lookup_df), by = "individual_id"))
}
```

## Transformations / batch corrections

```{r}
f_ <- formula(pheno ~ (1|group_pair/dir)) 
stan_prep_hoescht_dark <- feature_subset
stan_prep_hoescht_dark$response <- feature_subset$infocus_nucleus_hoechst_ser_dark_1px_mean

stan_prep_hoescht_dark$response  <- batch_correct(formula_ = f_, 'response', stan_prep_hoescht_dark, r.eff = 'dir:group_pair', target_col = 'dir', debug=FALSE)

# running twice -- apply scale 
stan_prep_hoescht_dark <- prepare_data_for_stan('response',
                                        stan_prep_hoescht_dark,
                                        scale = TRUE,
                                        log_ = FALSE)
```

## DRC initial stage + baseline

```{r}
library(magic) # this is added because of an environment mismatch somewhere

options(mc.cores = parallel::detectCores())
m.drc <- drc::drm(response ~ dose, 
  data = stan_prep_hoescht_dark,
  separate = TRUE, # make true if needing quick results
  curveid = individual_id,
  type = 'continuous',
  fct = drc::LL.4()
  )

m.drc.single <- drc::drm(response ~ dose, 
  data = stan_prep_hoescht_dark,
  type = 'continuous',
  fct = drc::LL.4())

ed50.drc <- prepare_ed50s_drc(m.drc, stan_prep_hoescht_dark)
```

## StanDRC

### Prior estimation

```{r}
c_estimate <- coef(m.drc.single)[2]
d_estimate <- coef(m.drc.single)[3]

slope_test <- stan_prep_hoescht_dark %>% 
  group_by(individual_id) %>% 
  nest() %>% 
  mutate(model = map(data, ~ lm(response ~ 1 + dose, data = .x) %>% tidy)) %>% 
  unnest(model) %>% 
  filter(term == 'dose')
```

### Model generation + priors

```{r}
m.stan <- standrm_harmony(
  formula=response ~ dose, 
  data=stan_prep_hoescht_dark, 
  fct = LL.4(), # slope, lower limit, upper limit, ed50
  curveid= b + e ~ individual_id,
  standrc_priors(e = "normal(pe, 1)", 
                 b = "normal(pb, 2)",
                 pb = slope_test$estimate, 
                 pc = c_estimate,
                 pd = d_estimate
                 ),
  random = b + c + d ~ dir_id,
iter = 2000, 
#chains = 4 
  )

# generate ED50 data for each individual
# functionality currently only for LL.4...
ed50.stan <- prepare_ed50s_stan(m.stan, stan_prep_hoescht_dark)

m.stan.single <- standrm_harmony(
  formula=response ~ dose, 
  data=stan_prep_hoescht_dark, fct = LL.4(),iter = 2000)
```


```{r}
ed50.stan <- map_do_to_original(ed50.stan,stan_prep_hoescht_dark)  %>%    
  subset(., select = which(!duplicated(names(.))))

ed50.drc <- map_do_to_original(ed50.drc,stan_prep_hoescht_dark)  %>%    
  subset(., select = which(!duplicated(names(.))))

dual_ed50_df <- rbind(ed50.drc,ed50.stan)
# dual_ed50_df <- map_do_to_original(dual_ed50_df,stan_prep_hoescht_dark)

# ggplot_build reverse engineers a ggplot object
plot_stan <- ggplot_build(plot(m.stan.single))

dev.off()

ggplot(data = stan_prep_hoescht_dark,
       aes(x = dose, y = response)) +
  geom_point(col = "grey", size= 0.1 ) + 
  geom_line(data = plot_stan$data[[3]], aes(x=x,y=y, col="why"), size= 3) +
  geom_smooth(method = drm, aes(col = "drc::L.4"), method.args = list(fct = L.4()), se = F) +
  geom_point(data = dual_ed50_df, aes(
    x = ed50,
    y = pred,
    color = group
    ), size = 0.7, shape = 3) +
  xlim(-1,10) + 
  # ggrepel::geom_text_repel(data= test, aes(label=individual,x=ed50,y=pred, color=group),size = 2,min.segment.length = 0, segment.color	="black") +
     ggrepel::geom_label_repel(data = dual_ed50_df,
  aes(
    x=ed50,
    y=pred,
    # fill = group, 
    label = individual),
  fontface = 'bold', 
  color = 'black',
  size = 1.7,
  nudge_y = 15,
  nudge_x = 1,
  min.segment.length = unit(0, 'lines'),
  #box.padding = unit(0.25, "lines"),
  #point.padding = unit(0.5, "lines"),
  max.overlaps = 20
) +
  scale_colour_manual(
    values=c("#0D4F8B", "#0D4F8B","red", "red"), 
    labels = c("drc L.4","ed50 drc","stan LL.4","ed50 stan"),
    guide = guide_legend(
      override.aes = list(
        linetype = c(1,NA,2,NA)
        ))) + 
  ggtitle("Hoescht Dark DRC + Stan fit/ed50 estimation") +
   scale_x_log10() #plots out the dataset with the corresponding 4-parameter log-logit dose response curves

```

### Comparative plots


```{r}
agg_values <- sqldf("select individual,min(response),max(response),median(response) as med_response, avg(response) as avg_response from stan_prep_hoescht_dark group by individual order by avg_response")

long_dual_ed50_df <- base::merge(x = ed50.drc, y = ed50.stan, by = "individual", all = TRUE)

# quick remove outliers
out <- boxplot.stats(long_dual_ed50_df$ed50.x)$out
out_ind <- which(long_dual_ed50_df$ed50.x %in% c(out))
subsubdat <- long_dual_ed50_df[-out_ind, ]

agg_w_stan <- merge(x = agg_values, y = ed50.stan, by = "individual", all = TRUE)

agg_w_drc <- merge(x = agg_values, y = subsubdat, by = "individual", all = TRUE)

p_2models <- ggplot() + 
  geom_point(data = subsubdat,aes(x=ed50.x, y=ed50.y),color='blue', size=0.6) +
  geom_smooth(data = subsubdat,aes(x=ed50.x, y=ed50.y),method = "lm", se = FALSE) +
  ggtitle("drc ed50 vs stan ed50 (drc outliers removed)")+
  xlim(0,5)+ ylim(0,5) + ylab("stan estimate") + xlab("drc estimate")+theme(text=element_text(size=5))

p_drc_meanreponse <- ggplot() + 
  geom_point(data = agg_w_drc,aes(x=avg_response, y=ed50.x),color='green', size=0.6) +
  geom_smooth(data = agg_w_drc,aes(x=avg_response, y=ed50.x),method = "lm", se = FALSE) +
  ggtitle("mean response vs drc ed50") +
  xlim(0,100)+ ylim(0,5)+theme(text=element_text(size=5))

p_stan_medianresponse <- ggplot() + 
  geom_point(data = agg_w_stan,aes(x=avg_response, y=ed50),color='red', size=0.6) +
  geom_smooth(data = agg_w_stan,aes(x=avg_response, y=ed50),method = "lm", se = FALSE) +
  ggtitle("mean response vs stan ed50") +
  xlim(0,100)+ ylim(0,5)+theme(text=element_text(size=5))

p_stan_meanresponse <- ggplot() + 
  geom_point(data = agg_w_stan,aes(x=med_response, y=ed50),color='red', size=0.6) +
  geom_smooth(data = agg_w_stan,aes(x=med_response, y=ed50), method = "lm", se = FALSE) +
  ggtitle("median response vs stan ed50") +
  xlim(0,100)+ ylim(0,5)+theme(text=element_text(size=5))

# plot 4
ggarrange(p_2models, p_drc_meanreponse, p_stan_medianresponse, p_stan_meanresponse, ncol = 2, nrow = 2)
```