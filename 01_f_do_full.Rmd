---
title: "DO #1f consolidated v1"
author:
- name: Robert Sellers
  affiliation: The Jackson Laboratory
date: "`r paste('Last knit on:',format(Sys.time(), '%d %B %Y'))`"
abstract: |
latex_engine: pdflatex
output:
  html_document:
    fig_caption: yes
    force_captions: yes
    number_sections: true
    theme: lumen
    toc: yes
    toc_float: yes
    df_print: paged
    # code_folding: "hide"
  pdf_document:
    fig_caption: yes
    force_captions: yes
    highlight: pyments
    keep_tex: yes
    latex_engine: xelatex
    number_sections: no
    toc: no
    
---

# Programming environment

```{r}
setwd("/Users/seller/Desktop/projects/jax_arsenic_toxicology_analysis")

# env
options(scipen = 999) # suppress sci notation

# contains harmony plate collection class builder
source("scripts/harmony_utils.R")
# various add-on scripts and stats tools
source("scripts/custom_tools.R")
# standrc code that actually works
source('scripts/standrc_evals.R')

library(tidyverse)
library(janitor)
library(ggplot2) 
library(ggfortify)
library(ggpubr)
library(lme4)
library(lmerTest)
library(sjPlot)
library(nlme)
library(dplyr)
library(standrc)
library(robustbase)
library(scales)
library(tibble)
library(broom)
library(plotly)
library(sqldf)
```

# Data setup

- recontruct initial data fixes to overwrite tempfile

```{r}
# point to parent data directory
setwd("data/invitro/")
selected_dir <- "./do_focus_merge_2"
# Warning - this currently expects a temp_files data dir 
# Set overwrite to TRUE when underlying data dir has been changed
harmony_collection <- harmony_create_collection(dir = selected_dir, overwrite = FALSE)
```

# Batch corrections

- control group 0 concentration (tbd)
- plate to plate (with lme4 or stan)

```{r}
# 
```

```{r}
# setwd("../analyses")
# callan_meansum_log <- readRDS('infocus_meansum_log.RDS')
# callan_log_dark <- subset(callan_meansum_log, outcome == 'infocus_nucleus_hoechst_ser_dark_1px_mean')[,c("individual","EC_50")]
```

# Analytics data construction

```{r}
feature_subset <- harmony_collection$all_plates %>%
  mutate(fdose=factor(dose)) %>%
  group_by(dir) %>%
  mutate(dir_id = cur_group_id()) %>%
  group_by(individual) %>%
  mutate(individual_id = cur_group_id())
```

# Dose response evaluation

```{r}
prepare_ed50s_stan <- function(model_, original_data){
  ed50_stan <- ED(model_, respLev=c(50))
  df = data.frame("individual_id" = sort(unique(original_data$individual_id)), "dose" = colMedians(ed50_stan$`50`))
  pred_stan <- predict_harmony(model_, newdata = df)
    df <- df %>% 
  rename(
    ed50 = dose
    )
  df$pred <- apply(pred_stan, 2, function(x) mean(x, na.rm=TRUE))
  df$group <- "stan"
  df$individual_id <- as.character(df$individual_id)
  return (df)
}

prepare_ed50s_drc <- function(model_, original_data){
  ed50_drc <- as.data.frame(drc::ED(model_, 50))
ed50_drc$individual <- str_match(rownames(ed50_drc), ":\\s*(.*?)\\s*:")[,2]
  # this might be a problem
  df = data.frame("individual_id" = as.character(ed50_drc$individual), "dose" = ed50_drc$Estimate)
  df$pred <- predict(model_, data.frame(
    dose = ed50_drc$Estimate,
    individual_id = str_match(rownames(ed50_drc), ":\\s*(.*?)\\s*:")[,2]
  ))
  df$group <- "drc"
  df$ed50 <- df$dose
  df$dose <- NULL
  return (df)
}

# batch correction lme4 auto script
batch_correct <- function(formula_,feature, data, r.eff, target_col, debug = FALSE){
  if (debug) browser()
  pheno_raw <- as.numeric(unlist(data[,c(feature)]))
  mn.pheno <- mean(pheno_raw, na.rm=TRUE)
  sd.pheno <- sd(pheno_raw, na.rm=TRUE)
  data$pheno <- (pheno_raw - mn.pheno) / sd.pheno
  fit <- lmer(formula_, data, REML=FALSE)
  random_effects <- ranef(fit)
  effects <- random_effects[[r.eff]]
  batch.ef <- effects[as.character(data[,c(target_col)][[1]]),]
  pheno_sub <- data$pheno - batch.ef
  pheno_adj <- (sd.pheno * pheno_sub) + mn.pheno
  return (pheno_adj)
}

# returns individual id to original value
map_do_to_original <- function(df_new, df_org){
  lookup_df <- df_org[,c('individual','individual_id')]
  return(plyr::join(df_new, distinct(lookup_df), by = "individual_id"))
}

plot_posterior_growth_ci <- function(fit, dat, cred = TRUE, title){
  Y_mean <- rstan::extract(fit, "Y_mean")
  Y_mean_mean <- apply(Y_mean$Y_mean, 2, mean)
  Y_pred <- rstan::extract(fit, "Y_pred")
  Y_pred_mean <- apply(Y_pred$Y_pred, 2, mean)
  
  if (cred){
    Y_mean_cred <- apply(Y_mean$Y_mean, 2, quantile, c(0.05, 0.95))
    Y_pred_cred <- apply(Y_pred$Y_pred, 2, quantile, c(0.05, 0.95))
    plot(dat$y ~ dat$x, xlab="x", ylab="Y", 
       ylim=c(-1, 101), main=title)
    lines(dat$x, Y_mean_mean)
    points(dat$x, Y_pred_mean, pch=19)
    lines(dat$x, Y_mean_cred[1,], col=4)
    lines(dat$x, Y_mean_cred[2,], col=4)
    lines(dat$x, Y_pred_cred[1,], col=2)
    lines(dat$x, Y_pred_cred[2,], col=2)
    legend(x="bottomright", bty="n", lwd=2, lty=c(NA, NA, 1, 1,1),
           legend=c("observation", "prediction", "mean prediction",
                    "90% mean cred. interval", "90% pred. cred. interval"),
           col=c(1,1,1,4,2),  pch=c(1, 19, NA, NA, NA))
  }else{
    plot(dat$y ~ dat$x, xlab="x", ylab="Y", 
       ylim=c(-1, 101), main="Non-linear Growth Curve")
    lines(dat$x, Y_mean_mean)
    points(dat$x, Y_pred_mean, pch=19)
    legend(x="bottomright", bty="n", lwd=2, lty=c(NA, NA, 1, 1,1),
           legend=c("observation", "prediction", "mean prediction"),
           col=c(1,1,1,4,2),  pch=c(1, 19, NA, NA, NA))
  }
}

build_standrc_object_single <- function(stan_dat, stancode, fit){
  out <- list()
  out$data <- stan_dat
  out$model <- stancode
  out$stan <- fit
  out$fixedpars <- c("slope","lasy","uasy","ed")
  out$pars <- c("pslope", "plasy", "puasy", "ped", "passym")
  out$curves <- list(pars=c(FALSE,FALSE,FALSE,FALSE),
                     J=1,
                     names=NULL
                     )
  out$fixed <- c(NA,NA,NA,NA,0)
  out$fct <- LL.4()
  class(out) <- "standrc"
  return(out)
}
```

## Transformations / batch corrections

```{r}
f_ <- formula(pheno ~ (1|group_pair/dir)) 
stan_prep_hoescht_dark <- feature_subset
stan_prep_hoescht_dark$response <- feature_subset$infocus_nucleus_hoechst_ser_dark_1px_mean

stan_prep_hoescht_dark$response  <- batch_correct(formula_ = f_, 'response', stan_prep_hoescht_dark, r.eff = 'dir:group_pair', target_col = 'dir', debug=FALSE)

# running twice -- apply scale 
stan_prep_hoescht_dark <- prepare_data_for_stan('response',
                                        stan_prep_hoescht_dark,
                                        scale = TRUE,
                                        log_ = FALSE)
```

## DRC initial stage + baseline

```{r}
library(magic) # this is added because of an environment mismatch somewhere

options(mc.cores = parallel::detectCores())
m.drc <- drc::drm(response ~ dose, 
  data = stan_prep_hoescht_dark,
  separate = TRUE, # make true if needing quick results
  curveid = individual_id,
  type = 'continuous',
  fct = drc::LL.4()
  )

m.drc.single <- drc::drm(response ~ dose, 
  data = stan_prep_hoescht_dark,
  type = 'continuous',
  fct = drc::LL.4())

ed50.drc <- prepare_ed50s_drc(m.drc, stan_prep_hoescht_dark)
```

## StanDRC

### Prior estimation

```{r}
c_estimate <- coef(m.drc.single)[2]
d_estimate <- coef(m.drc.single)[3]

slope_test <- stan_prep_hoescht_dark %>% 
  group_by(individual_id) %>% 
  nest() %>% 
  mutate(model = map(data, ~ lm(response ~ 1 + dose, data = .x) %>% tidy)) %>% 
  unnest(model) %>% 
  filter(term == 'dose')
```

### Model generation + priors

```{r}
m.stan <- standrm_harmony(
  formula=response ~ dose, 
  data=stan_prep_hoescht_dark, 
  fct = LL.4(), # slope, lower limit, upper limit, ed50
  curveid= b + e ~ individual_id,
  standrc_priors(e = "normal(pe, 1)", 
                 b = "normal(pb, 2)",
                 pb = slope_test$estimate, 
                 pc = c_estimate,
                 pd = d_estimate
                 ),
  random = b + c + d ~ dir_id,
iter = 2000, 
#chains = 4 
  )

# generate ED50 data for each individual
# functionality currently only for LL.4...
ed50.stan <- prepare_ed50s_stan(m.stan, stan_prep_hoescht_dark)

m.stan.single <- standrm_harmony(
  formula=response ~ dose, 
  data=stan_prep_hoescht_dark, fct = LL.4(),iter = 2000)
```


```{r}
ed50.stan <- map_do_to_original(ed50.stan,stan_prep_hoescht_dark)  %>%    
  subset(., select = which(!duplicated(names(.))))

ed50.drc <- map_do_to_original(ed50.drc,stan_prep_hoescht_dark)  %>%    
  subset(., select = which(!duplicated(names(.))))

dual_ed50_df <- rbind(ed50.drc,ed50.stan)
# dual_ed50_df <- map_do_to_original(dual_ed50_df,stan_prep_hoescht_dark)

# ggplot_build reverse engineers a ggplot object
plot_stan <- ggplot_build(plot(m.stan.single))

dev.off()

ggplot(data = stan_prep_hoescht_dark,
       aes(x = dose, y = response)) +
  geom_point(col = "grey", size= 0.1 ) + 
  geom_line(data = plot_stan$data[[3]], aes(x=x,y=y, col="why"), size= 3) +
  geom_smooth(method = drm, aes(col = "drc::L.4"), method.args = list(fct = L.4()), se = F) +
  geom_point(data = dual_ed50_df, aes(
    x = ed50,
    y = pred,
    color = group
    ), size = 0.7, shape = 3) +
  xlim(-1,10) + 
  # ggrepel::geom_text_repel(data= test, aes(label=individual,x=ed50,y=pred, color=group),size = 2,min.segment.length = 0, segment.color	="black") +
     ggrepel::geom_label_repel(data = dual_ed50_df,
  aes(
    x=ed50,
    y=pred,
    # fill = group, 
    label = individual),
  fontface = 'bold', 
  color = 'black',
  size = 1.7,
  nudge_y = 15,
  nudge_x = 1,
  min.segment.length = unit(0, 'lines'),
  #box.padding = unit(0.25, "lines"),
  #point.padding = unit(0.5, "lines"),
  max.overlaps = 20
) +
  scale_colour_manual(
    values=c("#0D4F8B", "#0D4F8B","red", "red"), 
    labels = c("drc L.4","ed50 drc","stan LL.4","ed50 stan"),
    guide = guide_legend(
      override.aes = list(
        linetype = c(1,NA,2,NA)
        ))) + 
  ggtitle("Hoescht Dark DRC + Stan fit/ed50 estimation") +
   scale_x_log10() #plots out the dataset with the corresponding 4-parameter log-logit dose response curves

```

### Comparative plots


```{r}
agg_values <- sqldf("select individual,min(response),max(response),median(response) as med_response, avg(response) as avg_response from stan_prep_hoescht_dark group by individual order by avg_response")

long_dual_ed50_df <- base::merge(x = ed50.drc, y = ed50.stan, by = "individual", all = TRUE)

# quick remove outliers
out <- boxplot.stats(long_dual_ed50_df$ed50.x)$out
out_ind <- which(long_dual_ed50_df$ed50.x %in% c(out))
subsubdat <- long_dual_ed50_df[-out_ind, ]

agg_w_stan <- merge(x = agg_values, y = ed50.stan, by = "individual", all = TRUE)

agg_w_drc <- merge(x = agg_values, y = subsubdat, by = "individual", all = TRUE)

p_2models <- ggplot() + 
  geom_point(data = subsubdat,aes(x=ed50.x, y=ed50.y),color='blue', size=0.6) +
  geom_smooth(data = subsubdat,aes(x=ed50.x, y=ed50.y),method = "lm", se = FALSE) +
  ggtitle("drc ed50 vs stan ed50 (drc outliers removed)")+
  xlim(0,5)+ ylim(0,5) + ylab("stan estimate") + xlab("drc estimate")+theme(text=element_text(size=5))

p_drc_meanreponse <- ggplot() + 
  geom_point(data = agg_w_drc,aes(x=avg_response, y=ed50.x),color='green', size=0.6) +
  geom_smooth(data = agg_w_drc,aes(x=avg_response, y=ed50.x),method = "lm", se = FALSE) +
  ggtitle("mean response vs drc ed50 (outliers removed)") +
  xlim(0,100)+ ylim(0,5)+theme(text=element_text(size=5))

p_stan_medianresponse <- ggplot() + 
  geom_point(data = agg_w_stan,aes(x=avg_response, y=ed50),color='red', size=0.6) +
  geom_smooth(data = agg_w_stan,aes(x=avg_response, y=ed50),method = "lm", se = FALSE) +
  ggtitle("mean response vs stan ed50") +
  xlim(0,100)+ ylim(0,5)+theme(text=element_text(size=5))

p_stan_meanresponse <- ggplot() + 
  geom_point(data = agg_w_stan,aes(x=med_response, y=ed50),color='red', size=0.6) +
  geom_smooth(data = agg_w_stan,aes(x=med_response, y=ed50), method = "lm", se = FALSE) +
  ggtitle("median response vs stan ed50") +
  xlim(0,100)+ ylim(0,5)+theme(text=element_text(size=5))

# plot 4
ggarrange(p_2models, p_drc_meanreponse, p_stan_medianresponse, p_stan_meanresponse, ncol = 2, nrow = 2)
```

# Migration from 01_g

## dataset construction

```{r}
# consider moving this above
stan_prep_hoescht_dark <- arrange(stan_prep_hoescht_dark, dose)
dat <- list(
  "N" = 7498,  
  "x" = stan_prep_hoescht_dark$dose,
  "y" = stan_prep_hoescht_dark$response,
  "pb" = 0,
  "pc" = 100,
  "pd" = 0.01,
  "pe" = 0.75,
  "pf" = 0)

# change zero values
invalid <- (dat$x == 0) == TRUE
dat$x[invalid] <- 0.005
# compare these two
#stan_dat <- readRDS("~/Desktop/example.RDS")
#diffobj::diffPrint(target=stan_dat, current=dat)
```

## Stan code

```{r}
stan_ll4 <- "
data {
  int<lower=0> N; 
  real y[N];
  real<lower=0> x[N];
  real pb; 
  real pc; 
  real pd; 
  real pe;
} 
parameters { 
  real<lower=0> sigmasq_y;
  real slope; 
  real lasy; 
  real uasy; 
  real<lower=0> ed;
} 
transformed parameters {
  real<lower=0> sigma_y;
  real mu[N];
  sigma_y = sqrt(sigmasq_y); 
  for(i in 1:N){ 
    mu[i] = lasy  + ( uasy - lasy ) / (1 + exp(-exp( slope ) * (log(x[i]/ ed ))))^exp( 0 );
  }
} 
model {
  slope ~ normal(pb, 100) ; 
  lasy ~ normal(pc, 100) ; 
  uasy ~ normal(pd, 100) ; 
  ed ~ normal(pe, 100) ;
  sigmasq_y ~ inv_gamma(0.001, 0.001) ; 
  y ~ normal(mu, sigma_y);
}
generated quantities {
  real Y_mean[N]; 
  real Y_pred[N]; 
  real residuals[N];
  real log_lik[N];
  real pslope; 
  real plasy; 
  real puasy; 
  real ped; 
  real passym;
  for (i in 1:N){
    residuals[i] = y[i] - mu[i];
    log_lik[i] = normal_log(y[i], mu[i], sigma_y);
    Y_mean[i] = lasy  + ( uasy - lasy ) / (1 + exp(-exp( slope ) * (log(x[i]/ ed ))))^exp( 0 );
    Y_pred[i] = normal_rng(Y_mean[i], sigma_y);   
  }
  pslope  =  slope  ; 
  plasy = lasy  ; 
  puasy  =  uasy  ; 
  ped  =  ed  ; 
  passym  =  0  ;
}
"
stan_growth <- "
data {
  int<lower=0> N; 
  real<lower=0> x[N];
  real y[N]; 
} 
parameters {
  real alpha; 
  real beta;  
  real<lower=.5,upper= 1> lambda; // original gamma in the JAGS example  
  real<lower=0> tau; 
} 
transformed parameters {
  real sigma; 
  real m[N];
  for (i in 1:N) 
    m[i] = alpha - beta * pow(lambda, x[i]);
  sigma = 1 / sqrt(tau); 
} 
model {
  // priors
  alpha ~ normal(0.0, 1000); 
  beta ~ normal(0.0, 1000); 
  lambda ~ uniform(.5, 1); 
  tau ~ gamma(.0001, .0001); 
  // likelihood
  y ~ normal(m, sigma);   
}
generated quantities{
  real Y_mean[N]; 
  real Y_pred[N]; 
  for(i in 1:N){
    // Posterior parameter distribution of the mean
    Y_mean[i] = alpha - beta * pow(lambda, x[i]);
    // Posterior predictive distribution
    Y_pred[i] = normal_rng(Y_mean[i], sigma);   
}
}
"
```

### Run Stan code

- single growth curve

```{r}
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
fit_growth <- stan(model_code = stan_growth, 
            model_name = "GrowthCurve", 
            data = dat)
```

- single ll4 curve

```{r}
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
fit_ll4 <- rstan::stan(model_code = stan_ll4, 
            model_name = "LL4Curve", 
            data = dat)
```

### Plots

```{r}
plot_posterior_growth_ci(fit_growth,dat, title="Non-linear growth Curve Hoescht Dark")
plot_posterior_growth_ci(fit_ll4, dat, title="Log-Logistic 4-param Hoescht Dark")
```