---
title: "DO #1a LMER custom test"
author:
- name: Robert Sellers
  affiliation: The Jackson Laboratory
date: "`r paste('Last knit on:',format(Sys.time(), '%d %B %Y'))`"
abstract: |
latex_engine: pdflatex
output:
  html_document:
    fig_caption: yes
    force_captions: yes
    number_sections: true
    theme: lumen
    toc: yes
    toc_float: yes
    df_print: paged
    # code_folding: "hide"
  pdf_document:
    fig_caption: yes
    force_captions: yes
    highlight: pyments
    keep_tex: yes
    latex_engine: xelatex
    number_sections: no
    toc: no
    
---

# Programming environment

```{r message=FALSE}
library(rstan)
```

# Load data

```{r}
getwd()
harmony_collection <- readRDS("../../temp_files/do_focus_merge_2_forstan.RData")
hoescht_features <- data.frame("feature" = c(
  "multi_nucleated_cells_numberofobjects", # similar
  "infocus_intensity_cell_hoechst_mean_mean", # similar
  "infocus_nucleus_hoechst_ser_dark_1px_mean", 
  "infocus_nucleus_hoechst_ser_edge_1px_mean" # similar
  ))

mitotracker_features <- data.frame("feature" = c(
  "nuclei_numberofobjects", # similar
  "infocus_intensity_cell_mitotrackerdeepred_mean_mean", # similar
  "infocus_cell_area_mm2_mean",
  "infocus_cell_mitotrackerdeepred_ser_edge_1px_mean" # similar
  ))
features_selected <- c(hoescht_features$feature,mitotracker_features$feature)

```

```{r}
feature_subset <- harmony_collection$analytics_subset %>%
  group_by(individual, dose) %>%
  summarise_at(vars(c(
    features_selected
    )), funs(m = mean(., na.rm = TRUE)))

feature_subset <- subset(feature_subset, complete.cases(feature_subset[,c('infocus_nucleus_hoechst_ser_dark_1px_mean_m', 'dose', 'individual')]))

# feature_subset$response <- as.integer(scales::rescale(feature_subset$infocus_nucleus_hoechst_ser_dark_1px_mean_m, to = c(1, 100), from = range(feature_subset$infocus_nucleus_hoechst_ser_dark_1px_mean_m, na.rm = TRUE, finite = TRUE)))

feature_subset$response <- feature_subset$infocus_nucleus_hoechst_ser_dark_1px_mean_m
  
dat_harmony <- list(
  "y" = feature_subset$response,
  "x" = feature_subset$dose,
  "N" = nrow(feature_subset)
) 


```


```{r}
growth_model <- "
  functions {
    real LL4(real x, real b, real a, real d, real c) {
      return c + (d - c) / (1 + exp(b * (log(x) - c)));
    }
  }
  data {
    int <lower=0> N;
    vector[N] x;
    vector[N] y;
  }
  parameters {
    real alpha; 
    real beta;  
    real <lower=0> a; //the minimum value that can be obtained 
    real <upper=1> d; //the maximum value that can be obtained 
    real <lower=0,upper=5> c; //the point of inflection 
    real <lower=-1,upper=1> b; //Hillâ€™s slope of the curve 
  real<lower=0> tau; 
  }
  transformed parameters {
    real sigma; 
    real m[N];
    for (i in 1:N) 
      m[i] = alpha - beta * pow(b, x[i]);
    sigma = 1 / sqrt(tau); 
  }
  model {
    a ~ normal(0,1);
    d ~ normal(0,1);
    c ~ normal(0,5);
    b ~ uniform(-1,1);
    // priors
    alpha ~ normal(0.0, 1000); 
    beta ~ normal(0.0, 1000); 
    //lambda ~ uniform(.5, 1); 
    tau ~ gamma(.0001, .0001); 
    // likelihood
    y ~ normal(m, sigma);   
  }
  generated quantities {
    real Y_mean[N]; 
    for(i in 1:N){
      // Posterior parameter distribution of the mean
      Y_mean[i] = alpha - beta * pow(b, x[i]);
    }
  }
"
```

# Run model

```{r}
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
fit <- stan(model_code = growth_model, 
            model_name = "GrowthCurve", 
            data = dat_harmony)

pairs(fit, pars = c("b", "c", "d", "ehat"))


# posterior
Y_mean <- extract(fit, "Y_mean")

Y_mean_mean <- apply(Y_mean$Y_mean, 2, mean)

plot(dat_harmony$y ~ factor(dat_harmony$x), xlab="dose", ylab="response", ylim=c(0, 1), main="DRC tests RStan")

lines(factor(dat_harmony$x), Y_mean_mean)
#points(factor(dat_harmony$x), Y_pred_mean, pch=19)
```

# Model extraction and plotting

```{r}
color_scheme_set("red")
bayesplot::ppc_dens_overlay(y = fit$y,
                 yrep = posterior_predict(fit, draws = 50))
```
